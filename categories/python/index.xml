<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Anders Pitman&#39;s blog</title>
    <link>http://anderspitman.com/categories/python/index.xml</link>
    <description>Recent content in Python on Anders Pitman&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](http://gohugo.io).</copyright>
    <atom:link href="http://anderspitman.com/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Asterisk ARI Quickstart Tutorial in Python</title>
      <link>http://anderspitman.com/2014/07/21/asterisk-ari-quickstart-in-python/</link>
      <pubDate>Mon, 21 Jul 2014 10:41:56 +0000</pubDate>
      
      <guid>http://anderspitman.com/2014/07/21/asterisk-ari-quickstart-in-python/</guid>
      <description>

&lt;p&gt;The purpose of this post is to get Asterisk users up and running with the Asterisk 12 ARI
with Python as quickly as possible. I&amp;rsquo;m assuming:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You know what the ARI is&lt;/li&gt;
&lt;li&gt;You know at least the basics of using Asterisk&lt;/li&gt;
&lt;li&gt;You have Asterisk 12 installed&lt;/li&gt;
&lt;li&gt;You have Python with pip installed (preferably inside a virtualenv)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I followed this other tutorial closely, particularly the implementation of
the websocket stuff:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.asterisk.org/wiki/display/AST/Getting+Started+with+ARI&#34;&gt;https://wiki.asterisk.org/wiki/display/AST/Getting+Started+with+ARI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For more info refer to the &lt;a href=&#34;https://wiki.asterisk.org/wiki/display/AST/Asterisk+12+ARI&#34;&gt;Official ARI Page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that I&amp;rsquo;m implementing my own interface for the REST calls, since it&amp;rsquo;s
a simple example. For a full blown application you&amp;rsquo;ll probably want to use something
like &lt;a href=&#34;https://github.com/kickstandproject/python-ari&#34;&gt;python-ari&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;set-up-asterisk&#34;&gt;Set up Asterisk&lt;/h2&gt;

&lt;h3 id=&#34;enable-http-server&#34;&gt;Enable HTTP server&lt;/h3&gt;

&lt;p&gt;Asterisk&amp;rsquo;s HTTP server is disabled by default. Open &lt;strong&gt;http.conf&lt;/strong&gt; and make sure
the following are uncommented.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enabled=yes
bindaddr=127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enable-and-set-up-ari&#34;&gt;Enable and set up ARI&lt;/h3&gt;

&lt;p&gt;Open &lt;strong&gt;ari.conf&lt;/strong&gt; and uncomment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enabled=yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add the following to the end of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[hey]
type=user
password=peekaboo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-an-extension&#34;&gt;Create an extension&lt;/h3&gt;

&lt;p&gt;We need an entry point for Asterisk to pass control into our ARI app. Just
set up an extension that opens the Statis app as shown below. I&amp;rsquo;m using
extension 100 in the example &lt;strong&gt;extensions.conf&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[default]
exten =&amp;gt; 100,1,Noop()
      same =&amp;gt; n,Stasis(hello,world) ; hello is the name of the application
                                    ; world is its argument list
      same =&amp;gt; n,Hangup()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-the-code&#34;&gt;Get the Code&lt;/h2&gt;

&lt;p&gt;Either clone my repo at &lt;a href=&#34;https://github.com/anderspitman/ari-quickstart&#34;&gt;https://github.com/anderspitman/ari-quickstart&lt;/a&gt; or
just copy and paste the script from below.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need to install requests and websocket-client. If you cloned the
repo just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise install them manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install requests websocket-client
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

import json
import sys
import websocket
import threading
import Queue
import requests


class ARIInterface(object):
    def __init__(self, server_addr, username, password):
        self._req_base = &amp;quot;http://%s:8088/ari/&amp;quot; % server_addr
        self._username = username
        self._password = password

    def answer_call(self, channel_id):
        req_str = self._req_base+&amp;quot;channels/%s/answer&amp;quot; % channel_id
        self._send_post_request(req_str)

    def play_sound(self, channel_id, sound_name):
        req_str = self._req_base+(&amp;quot;channels/%s/play?media=sound:%s&amp;quot; % (channel_id, sound_name))
        self._send_post_request(req_str)

    def _send_post_request(self, req_str):
        r = requests.post(req_str, auth=(self._username, self._password))


class ARIApp(object):
    def __init__(self, server_addr):
        app_name = &#39;hello&#39;
        username = &#39;hey&#39;
        password = &#39;peekaboo&#39;
        url = &amp;quot;ws://%s:8088/ari/events?app=%s&amp;amp;api_key=%s:%s&amp;quot; % (server_addr, app_name, username, password)
        ari = ARIInterface(server_addr, username, password)
        ws = websocket.create_connection(url)

        try:
            for event_str in iter(lambda: ws.recv(), None):
                event_json = json.loads(event_str)

                json.dump(event_json, sys.stdout, indent=2, sort_keys=True,
                          separators=(&#39;,&#39;, &#39;: &#39;))
                print(&amp;quot;\n\nWebsocket event***************************************************\n&amp;quot;)

                if event_json[&#39;type&#39;] == &#39;StasisStart&#39;:
                    ari.answer_call(event_json[&#39;channel&#39;][&#39;id&#39;])
                    ari.play_sound(event_json[&#39;channel&#39;][&#39;id&#39;], &#39;tt-monkeys&#39;)
        except websocket.WebSocketConnectionClosedException:
            print(&amp;quot;Websocket connection closed&amp;quot;)
        except KeyboardInterrupt:
            print(&amp;quot;Keyboard interrupt&amp;quot;)
        finally:
            if ws:
                ws.close()


if __name__ == &amp;quot;__main__&amp;quot;:
    app = ARIApp(&#39;localhost&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;try-it-out&#34;&gt;Try it Out&lt;/h2&gt;

&lt;p&gt;Start/Restart Asterisk and once it&amp;rsquo;s up run the script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python ari-quickstart.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it doesn&amp;rsquo;t throw any exceptions it should be connected and listening for ARI
events. Dial the Statis extension (100 in my case) and you should hear monkeys.&lt;/p&gt;

&lt;p&gt;The script should be easy to modify to add more functionality. It&amp;rsquo;s a good
starting point for creating more full featured apps. The biggest thing
to worry about is that there&amp;rsquo;s a good chance you won&amp;rsquo;t want your app
blocking on the websocket receive calls. A simple solution is to handle
events in a separate thread and use a Python queue to pass the received
messages in.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting up an IPython Development Environment from Source</title>
      <link>http://anderspitman.com/2014/06/15/setting-up-an-ipython-development-environment-from-source/</link>
      <pubDate>Sun, 15 Jun 2014 22:40:00 +0000</pubDate>
      
      <guid>http://anderspitman.com/2014/06/15/setting-up-an-ipython-development-environment-from-source/</guid>
      <description>

&lt;p&gt;I recently decided to start hacking on the excellent &lt;a href=&#34;http://ipython.org/&#34;&gt;IPython&lt;/a&gt;
project. I wanted
to have full control over the versions of all the software involved, which
meant compiling Python from source. This guide is intended to take one through
the entire process of setting up a custom Python build with virtualenv in the
least number of steps possible, with the final goal of building a virtualenv
specifically for IPython dev work.&lt;/p&gt;

&lt;p&gt;For this guide I&amp;rsquo;m using Mint 17 (based on Ubuntu 14.04). Most of the commands
should be very similar for most modern Linux systems. The biggest things that
will be different is installing build dependencies. Usually on debian based
system that will involve something along the lines of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And maybe a few other packages.&lt;/p&gt;

&lt;h2 id=&#34;building-and-installing-python&#34;&gt;Building and Installing Python&lt;/h2&gt;

&lt;p&gt;For this example I will be installing to /opt/python277. First, create the
directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo mkdir -p /opt/python277
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ll get the python source.
I want to use the latest Python 2.7. As of this writing it&amp;rsquo;s 2.7.7.
get it &lt;a href=&#34;https://www.python.org/ftp/python/2.7.7/Python-2.7.7.tar.xz&#34;&gt;here&lt;/a&gt;.
You should be able to follow these instructions with any 2.7.x version. 3.x
should work as well, but might be a little different.&lt;/p&gt;

&lt;p&gt;Extract the downloaded tarball and go into the directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -xvf Python-2.7.7.tar.xz
cd Python-2.7.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will now configure Python source:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export LD_RUN_PATH=/opt/python277/lib
./configure --prefix=/opt/python277 --enable-shared
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we&amp;rsquo;re doing here is telling python to install to /opt/python277
and to be available as a shared library. This is important for
certain packages such as PySide, which we&amp;rsquo;ll install later. The LD_RUN_PATH tells it which
library our python executable should link against at runtime. If
we didn&amp;rsquo;t set that environment variable, it would link against the
system&amp;rsquo;s python library, which causes all sorts of confusion.&lt;/p&gt;

&lt;p&gt;Now make and install:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install a fresh python into /opt/python277. You can test it by running&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/opt/python277/bin/python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should get a python 2.7.7 prompt.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-package-management-and-virtualenv&#34;&gt;Setting up Package Management and virtualenv&lt;/h2&gt;

&lt;p&gt;The next thing we want to do is get pip up and running as quickly as possible,
so that we can use it for all our package management. We&amp;rsquo;ll download pip
directory from pypi. It depends on setuptools, so download that
&lt;a href=&#34;https://pypi.python.org/packages/source/s/setuptools/setuptools-4.0.1.tar.gz#md5=190b1d4470de9bae0b4414353e14700d&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then extract and install it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -xzvf setuptools-4.0.1.tar.gz
cd setuptools-4.0.1/
sudo /opt/python277/bin/python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now do the same thing with pip. The one I used is
&lt;a href=&#34;https://pypi.python.org/packages/source/p/pip/pip-1.5.6.tar.gz#md5=01026f87978932060cc86c1dc527903e&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -xzvf pip-1.5.6.tar.gz
cd pip-1.5.6/
sudo /opt/python277/bin/python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, we should now be able to install most python packages from pypi simply
with pip now. The first thing we need is virtualenv. If you&amp;rsquo;re not familiar with
virtualenv, it&amp;rsquo;s awesome. Check it out &lt;a href=&#34;http://virtualenv.readthedocs.org/en/latest/&#34;&gt;here&lt;/a&gt;.
Install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo /opt/python277/bin/pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-up-ipython-virtualenv&#34;&gt;Set up IPython virtualenv&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll now create a virtualenv just for ipython development. I like to keep my
virtualenvs in ~/virt_python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/virt_python
cd ~/virt_python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create the virtualenv. I&amp;rsquo;ll call it &amp;ldquo;ipython-dev&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/opt/python277/bin/virtualenv ipython-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activate it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ipython-dev/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we run python or pip it will use the executables in
~/virt_python/ipython-dev, and any packages we install with pip
will only affect our ipython virtualenv.&lt;/p&gt;

&lt;h2 id=&#34;install-dependencies&#34;&gt;Install Dependencies&lt;/h2&gt;

&lt;p&gt;The IPython dependencies we need will depend on which parts of IPython you want
to work on. For example, to run the notebook we&amp;rsquo;ll want numpy, ZeroMQ, jinja,
and tornado. It&amp;rsquo;s now simply a
matter of using pip:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install numpy pyzmq jinja2 tornado
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively you can install the dependencies for a specific IPython console
automatically as explained below.&lt;/p&gt;

&lt;p&gt;I want to run the IPython QT console, which depends on QT. I like the &lt;a href=&#34;http://qt-project.org/wiki/pyside&#34;&gt;PySide&lt;/a&gt;
python bindings. First install QT. On my system I needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install qt4-default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then install PySide:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PYTHON_INCLUDE_DIRS=/opt/python277/lib
pip install pyside
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to set PYTHON_INCLUDE_DIRS so that qmake knows what to build against.&lt;/p&gt;

&lt;h2 id=&#34;get-the-ipython-source&#34;&gt;Get the IPython Source&lt;/h2&gt;

&lt;p&gt;Clone the repository from github into ~/ipython-dev:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd
git clone https://github.com/ipython/ipython ipython-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install dependencies for the IPython notebook with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -e &amp;quot;.[notebook]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also creates an IPython executable in your virtualenv so as long as it is
active you can simply run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipython
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to run IPython from your development source.&lt;/p&gt;

&lt;p&gt;You should now be set to start hacking!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>